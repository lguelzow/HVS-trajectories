# Main simulation file!
# It reads the data generated by 'M31-trajectory.txt' and 'RNG_initial_conditions.txt'
# and uses them in the calculation of the HVS trajectories.
# The file establishes all tools needed by ODEint for solving the differential equations
# and afterwards filters the results and transforms them to Galactic coordinates
# in the heliocentric rest frame.
# The results are written into a result file for the separate plotting files.

#
'''TABLE OF CONTENTS: '''
#

# 1.) MODULES
#     - import all modules needed in file
#
# 2.) CONSTANTS AND PARAMETERS
#     - establish constants and set parameters that don't change over the course of the calculation
#
# 3.) TEXTFILES TO SAVE RESULTS
#     - create textfiles for results of calculation and write column headers
#
# 4.) VARIABLE PARAMETERS
#     - define parameters and functions that change over the course of the calculation
#
# 5.) ARRAYS FOR RESULTS
#     - define arrays to filtered results into
#
# 6.) INITIAL CONDITIONS
#     - read out initial conditions from 'RNG_initial_conditions.txt' and
#       get the initial position and velocity vectors, and the initial time from it
#
# 7.) MAIN CALCULATION
#     - define arrays for intermediate results from every step
#     - define differential equations in function 'diff_eq'
#     - generate list of solutions 'sol' with ODEint
#     - 'sol' is a list of the position and velocity of one HVS at every time step of the simulation
#
# 8.) FILTERING OF RESULTS
#     - get the values at t_0 = 13.8Gyrs and writing them into the result arrays from Sec. 4.)
#     - apply first filter step of d_MW < 50kpc
#
# 9.) TRANSFORMATION TO GALACTIC CARTESIAN COORDINATES
#     - on both position and velocity vector:
#     - perform shift of origin to the Sun
#     - perform two coordinate rotations to align axes with Gal. Cart. coordinates
#     - boost velocity vectors to heliocentric rest frame
#
# 10.) TRANSFORMATION TO GALACTIC COORDINATES
#     - transform to Galactic coordinates with spherical transformation
#     - read data into a Skycoord array for plotting and transformation to equatorial coordinates
#
# 11.) WRITE FINAL RESULTS INTO DATA FILE
#     - write into results file: distance to the Sun, time, Galactic coordinates of HVS,
#       RA/DEC of HVS, velocity magnitude, Cartesian velocity components, Galactic velocity direction coordinates

#
'''MODULES:'''
#

# First import some modules


#
'''CONSTANTS AND PARAMETERS: '''
#

# age of the universe [Myr]
import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import odeint
from scipy.interpolate import interp1d
import sys
import astropy
from astropy.coordinates import SkyCoord
import astropy.units as u
t_0 = 13800

# length of time interval
time_steps = 10001

# rescaled grav. constant [kpc^3/(Myr^2 * M_o)]
G = 4.49948902 * 10 ** (-12)

# Milky Way scale radius for NFW dark matter profile [kpc]
R_s1 = 20.

# Andromeda scale radius for NFW dark matter profile [kpc]
R_s2 = 20.  # Andromeda scale radius for NFW dark matter profile [kpc]

# Plummer radius of galaxies for Plummer term in differential eq., considers only baryonic matter [kpc]
a = 5

# dark matter density off halo at scale radius [M_o/kpc^3] (for R_s = 20kpc and M = 1/2 * 5/6 * M_LG)
rho_0 = 1.172377895 * 10 ** 7

# total mass of both galaxies [M_o]
M_LG = 4.211301617 * 10 ** 12

# baryonic masses of each galaxy [M_o]
M1 = 0.5 * M_LG / 6   # Mass of Milky Way
M2 = 0.5 * M_LG / 6   # Mass of Andromeda

# position of the Sun in Kartesian coordinate system centered on MW centre
r_Sun = [4.003551, 7.13161944, 0.]

# velocity vector of the sun in the Milky Way rest frame (in galactic cartesian coordinates) [km/s]
sun_vel = [11.1, 12.24 + 240, 7.25]

# transformation constant (kpc/Myr -> km/s)
trafo = 1000 / 1.023

# both of these angles at present time:
# angle between (simulation) x-axis and MW galactic coordinate (0,0)-axis [rad]
epsilon = 2.08233

# angle between simulation x-y-plane and MW galactic plane [rad]
phi = -0.4328320437

# rotation matrices for coordinate transformation at the end
# rotation matrix for rotation around z-axis
Rot_z = np.array([[np.cos(epsilon), np.sin(epsilon) * (-1), 0],
                  [np.sin(epsilon), np.cos(epsilon), 0], [0, 0, 1]])

# rotation matrix for rotation around x-axis
Rot_x = np.array([[1, 0, 0], [0, np.cos(phi), np.sin(phi) * (-1)],
                  [0, np.sin(phi), np.cos(phi)]])


#
'''TEXTFILES TO SAVE RESULTS: '''
#

# save all distances to the Sun in a textfile + save all really small min. distances in a separate file
np.savetxt("distances-to-sun.txt", [])
np.savetxt("smallest-min-distances.txt", [])
np.savetxt("MW-centre-vel.txt", [])

f = open("distances-to-sun.txt", "w")
g = open("smallest-min-distances.txt", "w")
h = open("MW-centre-vel.txt", "w")

# write column headers into each first line
f.write("Minimum_distance_to_Sun[kpc]" + " " + "\n")
g.write("Minimum_distance_to_Sun[kpc]" + " " + "Time[Myr]" + " " + "Galactic_longitude[deg]" + " " + "Galactic_latitude[deg]" + " " + "Right_ascension[hms]" + " " + "Declination[dms]" + " " +
        "Velocity_magnitude[kpc/Myr]" + " " + "vx[kpc/Myr]" + " " + "vy[kpc/Myr]" + " " + "vz[kpc/Myr]" + " " + "Gal_long_of_v[deg]" + " " + "Gal_lat_of_v[deg]" + " " + "Initial_send-off_time_test_star[Myr]" + "\n")
h.write("Minimum_distance_to_Sun[kpc]" + " " + "Time_coordinate[Myr]" + " " + "Velocity_at_min_distance[kpc/Myr]" + " " + "vx[kpc/Myr]" + " " +
        "vy[kpc/Myr]" + " " + "vz[kpc/Myr]" + " " + "Initial_velocity_magnitude_of_test_star[kpc/Myr]" + " " + "Initial_send-off_time_test_star[Myr]" + "\n")


#
'''VARIABLE PARAMETERS: '''
#

# Read the data of the movement of Andromeda from data file
readout1 = np.loadtxt('M31-trajectory.txt', dtype=np.str)
# option for HPC array and the specific filesystem
# readout1 = np.loadtxt('/upb/departments/pc2/users/h/hypvel02/Python_files/new_test/M31-position.txt', dtype=np.str)


# Convert the whole table into an array of strings
# call: readout variable
M31_array = np.array(readout1)

# print(len(M31_array))

# Define the array of time steps in the Andromeda table
t_M31 = [None] * (len(M31_array) - 1)

# Get the time values from the readout variable and convert the strings into floats
for x in range(len(M31_array) - 1):
    t_M31[x] = float(M31_array[x + 1, 0])


# Define arrays for components of Andromeda position vector
# x, y and z components
x_Andr = [None] * (len(M31_array) - 1)

y_Andr = [None] * (len(M31_array) - 1)

z_Andr = [None] * (len(M31_array) - 1)

# x, y and z components of the velocity
vx_Andr = [None] * (len(M31_array) - 1)

vy_Andr = [None] * (len(M31_array) - 1)

vz_Andr = [None] * (len(M31_array) - 1)


# readout Andromeda position from readout variable
for x in range(len(M31_array) - 1):
    # Get the x values from the big table and convert the strings into floats
    x_Andr[x] = float(M31_array[x + 1, 1])

    # Get the y values from the big table and convert the strings into floats
    y_Andr[x] = float(M31_array[x + 1, 2])

    # Get the z values from the big table and convert the strings into floats
    z_Andr[x] = float(M31_array[x + 1, 3])

   # Now do the same for the components of the velocity vector
   # Get the x-direction velocity values from the big table and convert the strings into floats
    vx_Andr[x] = float(M31_array[x + 1, 4])

    # Get the y-direction velocity values from the big table and convert the strings into floats
    vy_Andr[x] = float(M31_array[x + 1, 5])

    # Get the z-direction velocity values from the big table and convert the strings into floats
    vz_Andr[x] = float(M31_array[x + 1, 6])

# print(vx_Andr[0])


# interpolate the position and velocity arrays into continuous functions of ttime with interp1D
A_xfunc = interp1d(t_M31, x_Andr, bounds_error=False, fill_value="extrapolate")

A_yfunc = interp1d(t_M31, y_Andr, bounds_error=False, fill_value="extrapolate")

A_zfunc = interp1d(t_M31, z_Andr, bounds_error=False, fill_value="extrapolate")


# repeat for the velocities
A_vxfunc = interp1d(t_M31, vx_Andr, bounds_error=False,
                    fill_value="extrapolate")

A_vyfunc = interp1d(t_M31, vy_Andr, bounds_error=False,
                    fill_value="extrapolate")

A_vzfunc = interp1d(t_M31, vz_Andr, bounds_error=False,
                    fill_value="extrapolate")

# print(A_vxfunc(10000))

# plt.plot(A_xfunc(t))
# plt.show()


#
'''ARRAYS FOR RESULTS: '''
#

# Read out the randomly generated initial conditions from text file
# here and not in the initial conditions section because we need the amount
#  of initial conditions for the length of the result arrays
readout2 = np.loadtxt('HVS-initial-conditions.txt', dtype=np.str)

# convert the readout into an array of strings
# conversion to floats is in the for-loop
ini = np.array(readout2)

# base arrays on amount of initial conditions
# define array of minimum distance to Milky Way in every timestep
min_D = [None] * (len(ini) - 1)


# first filtered arrays for values at minimum distance
# list the minimum distances under 50 kpc to the MW centre
sub_50 = []

# the corresponding position coordinates
sub_50_coord = []

# and the corresponding velocity magnitudes
sub_50_mag_vel = []

# and initial velocity magnitudes
sub_50_ini_vel = []

# and initial time
sub_50_ini_time = []

# and their corresponding velocity components
sub_50_vel = []

# and times
sub_50_t = []


#
'''INITIAL CONDITIONS: '''
#

# for-loop to let the code run as many times as there are innitial conditions
for i in range(len(ini) - 1):

    # display progress of calculation on command line
    if i % 100 == 0:
        sys.stdout.write("\rProgress:" + str(float(i) / (len(ini) - 1)))
        sys.stdout.flush()

    # process the randomly generated initial conditions
    # and generate the time frame of the calculation
    # and find the initial position and velocity vector

    # get the initial send-off time and generate the time array for ODEint from it
    t_ini = float(ini[i + 1, 0])

    # define time interval from randomly generated initial time
    t = np.linspace(t_ini, t_0, time_steps)

    # print(len(t))

    # write the initial distance values into an array and converting them back to floats
    r0 = [None] * 3
    for x in range(3):
        r0[x] = float(ini[i + 1, x + 1])

    # print(r0)

    # write the initial velocity values into an array and converting them back to floats
    v0 = [None] * 3
    for x in range(3):
        v0[x] = float(ini[i + 1, x + 4])

    # print(v0)

    # add Andromeda's initial position from the arrays to test star initial position
    # to get the complete initial HVS position vector [kpc]
    r0[0] += A_xfunc(t_ini)
    r0[1] += A_yfunc(t_ini)
    r0[2] += A_zfunc(t_ini)

    # print(r0)

    # add initial velocity of Andromeda to HVS initial velocity [kpc/Myr]
    v0[0] += A_vxfunc(t_ini)
    v0[1] += A_vyfunc(t_ini)
    v0[2] += A_vzfunc(t_ini)

    # write down initial HVS velocity magnitude for secondary result file
    ini_vel_mag = (v0[0] ** 2 + v0[1] ** 2 + v0[2] ** 2) ** 0.5

    # print(v0)

    # build HVS initial vectors out of readout variable initial conditions[(r[kpc], v[kpc/Myr])]
    y0 = [r0[0], v0[0], r0[1], v0[1], r0[2], v0[2]]

    # print(y0)

    #
    '''MAIN CALCULATION:'''
    #

    # define array of distance to Milky Way for every timestep to find out the minimum distance
    distance_list = [None] * len(t)

    # define array for distance to the Sun at t_0
    sun_distance = []

    # define array for distance to the MW centre at t_0
    MW_distance = []

    # array for position coordinates at t_0
    position = []

    # define array for velocity magnitude at t_0
    mag_vel = []

    # define array for velocity components at t_0
    veloc = []

    # define array for time value at t_0 (redundant, but kept for number of columns in result file)
    min_t = []

    # Define the vector y = [r, v] which will be our solution and a time interval
    #
    # Then diff_eq returns a vector of the derivatives dydt = [r'(t), v'(t)]
    #
    # Solve the six DEs simultaneously with ODEint

    def diff_eq(y0, t, G, R_s1, R_s2, M1, M2):
        # Unpack the vector y = [rx, vx, ry, vy, rz, vz]
        rx, vx, ry, vy, rz, vz = y0

        # magnitude of distance and velocity vector to Milky Way
        mag_r = (rx ** 2 + ry ** 2 + rz ** 2) ** 0.5
        # mag_v = (vx ** 2 + vy ** 2 + vz ** 2) ** 0.5

        # magnitude of distance vector to Andromeda
        mag_andr = ((rx - A_xfunc(t)) ** 2 +
                    (ry - A_yfunc(t)) ** 2 + (rz - A_zfunc(t)) ** 2) ** 0.5

       # calculate differential equations [v_i, a_i]
        dy1dt = [vx, 4 * np.pi * G * (rho_0 * R_s1 ** 3 * (mag_r / (R_s1 + mag_r) - np.log((R_s1 + mag_r) / R_s1)) * rx / (mag_r ** 3) + rho_0 * R_s2 ** 3 * (mag_andr / (R_s2 + mag_andr) - np.log(
            (R_s2 + mag_andr) / R_s2)) * (rx - A_xfunc(t)) / (mag_andr) ** 3 - M1 * rx / (4 * np.pi * (mag_r ** 2 + a ** 2) ** 1.5) - M2 * (rx - A_xfunc(t)) / (4 * np.pi * (mag_andr ** 2 + a ** 2) ** 1.5))]
        # print(dy1dt)

        dy2dt = [vy, 4 * np.pi * G * (rho_0 * R_s1 ** 3 * (mag_r / (R_s1 + mag_r) - np.log((R_s1 + mag_r) / R_s1)) * ry / (mag_r ** 3) + rho_0 * R_s2 ** 3 * (mag_andr / (R_s2 + mag_andr) - np.log(
            (R_s2 + mag_andr) / R_s2)) * (ry - A_yfunc(t)) / (mag_andr) ** 3 - M1 * ry / (4 * np.pi * (mag_r ** 2 + a ** 2) ** 1.5) - M2 * (ry - A_yfunc(t)) / (4 * np.pi * (mag_andr ** 2 + a ** 2) ** 1.5))]
        # print(dy2dt)

        dy3dt = [vz, 4 * np.pi * G * (rho_0 * R_s1 ** 3 * (mag_r / (R_s1 + mag_r) - np.log((R_s1 + mag_r) / R_s1)) * rz / (mag_r ** 3) + rho_0 * R_s2 ** 3 * (mag_andr / (R_s2 + mag_andr) - np.log(
            (R_s2 + mag_andr) / R_s2)) * (rz - A_zfunc(t)) / (mag_andr) ** 3 - M1 * rz / (4 * np.pi * (mag_r ** 2 + a ** 2) ** 1.5) - M2 * (rz - A_zfunc(t)) / (4 * np.pi * (mag_andr ** 2 + a ** 2) ** 1.5))]
        # print(dy3dt)DE

        return dy1dt + dy2dt + dy3dt

    # Finally find the solution using scipy.odeint
    sol = odeint(diff_eq, y0, t, args=(G, R_s1, R_s2, M1, M2))
    # This gives a (len(t), 6) array with the columns corresponding to [rx, vx, ry, vy, rz, vz]

    #
    '''FILTERING OF RESULTS: '''
    #

    # define distance to compare to filter criterium for distance to MW centre
    MW_filter_dist = (sol[time_steps - 1][0] ** 2 + sol[time_steps - 1]
                      [2] ** 2 + sol[time_steps - 1][4] ** 2) ** 0.5

    # print(sun_filter_dist)
    # print(t[time_steps - 1])

    # make lists for results from sol = [rx, vx, ry, vy, rz, vz]
    for x in range(time_steps):

        # list for distance to the sun in every timestep
        distance_list[x] = ((sol[x][0] - r_Sun[0]) ** 2 + (sol[x]
                                                           [2] - r_Sun[1]) ** 2 + (sol[x][4] - r_Sun[2]) ** 2) ** 0.5

        # last time step
        # t_l = time_steps - 1

        # filter t = 13.8Gyr and 500kpc MW centre distance
        # then append eligible entries to the result arrays
        if t[x] == 13800 and MW_filter_dist < 500:
            # list for distance to the sun for filtering
            sun_distance.append(((sol[x][0] - r_Sun[0]) ** 2 + (sol[x]
                                                                [2] - r_Sun[1]) ** 2 + (sol[x][4] - r_Sun[2]) ** 2) ** 0.5)
            # list for distance to MW-centre
            MW_distance.append(
                (sol[x][0] ** 2 + sol[x][2] ** 2 + sol[x][4] ** 2) ** 0.5)
            # list for coordinates in galacto-centric frame
            position.append([sol[x][0], sol[x][2], sol[x][4]])
            # list for velocity magnitude
            mag_vel.append((sol[x][1] ** 2 + sol[x][3]
                            ** 2 + sol[x][5] ** 2) ** 0.5)
            # list for velocity vectors
            veloc.append([sol[x][1], sol[x][3], sol[x][5]])
            # list for corresponding points in time
            min_t.append(t[x])

    # find the minimum distance for each iteration and write it into the corresponding array
    min_D[i] = np.amin(distance_list)

    # print(len(sun_distance))

    # find the distance to the Sun + corresponding values for position coordinates, velocity and time in the result list
    # and write them into a separate array (filtered around the Sun)
    if len(sun_distance) > 0:
        if np.amin(MW_distance) < 50:
            sub_50.append(np.amin(sun_distance))
            sub_50_coord.append(position[np.argmin(sun_distance)])
            sub_50_mag_vel.append(mag_vel[np.argmin(sun_distance)])
            sub_50_vel.append(veloc[np.argmin(sun_distance)])
            sub_50_t.append(min_t[np.argmin(sun_distance)])
            sub_50_ini_vel.append(ini_vel_mag)
            sub_50_ini_time.append(t_ini)

    # write minimum distances to Sun into data file
    f.write(str(min_D[i]) + " " + "\n")

    # print(len(MW_distance))
    # print(mag_vel[0:10])
    # print(t[0:10])
    # print(sol)
    # print(MW_distance)


#
'''TRANSFORMATION TO GALACTIC CARTESIAN COORDINATES'''
#

# transform results to Cartesian coordinates centered on the Sun
for i in range(len(sub_50)):
    sub_50_coord[i] = [sub_50_coord[i][0] - r_Sun[0],
                       sub_50_coord[i][1] - r_Sun[1], sub_50_coord[i][2] - r_Sun[2]]
    sub_50[i] = (sub_50_coord[i][0] ** 2 + sub_50_coord[i][1]
                 ** 2 + sub_50_coord[i][2] ** 2) ** 0.5

# print("\n" + str(sub_200_coord[0]))
# print(sub_200[0])


# define arrays for the final results for the distance, spacial coordinates, velocity magnitude, velocity components and time
sub_13 = []
sub_13_coord = []
sub_13_mag_vel = []
sub_13_vel = []
sub_13_t = []
sub_13_ini_time = []


# filter the distances again for 13kpc around the Sun
for i in range(len(sub_50)):
    if sub_50[i] < 13:  # and sub_50_t[i] > 13790:
        sub_13.append(sub_50[i])
        sub_13_coord.append(sub_50_coord[i])
        sub_13_mag_vel.append(sub_50_mag_vel[i])
        sub_13_vel.append(sub_50_vel[i])
        sub_13_t.append(sub_50_t[i])
        sub_13_ini_time.append(sub_50_ini_time[i])


#
# transform the remaining points to Galactic Cartesian coordinates and then to RA/DEC with these steps
#

# rotate the katesian coordinate system so that the MW centre is at y = z = 0 and x > 0
for i in range(len(sub_13)):
    sub_13_coord[i] = np.dot(Rot_z, sub_13_coord[i])
    sub_13_coord[i] = np.dot(Rot_x, sub_13_coord[i])

    sub_13_vel[i] = np.dot(Rot_z, sub_13_vel[i])
    sub_13_vel[i] = np.dot(Rot_x, sub_13_vel[i])


# also rotate velocity of sub50 results to boost them to heliocentric rest frame
for i in range(len(sub_50)):
    sub_50_vel[i] = np.dot(Rot_z, sub_50_vel[i])
    sub_50_vel[i] = np.dot(Rot_x, sub_50_vel[i])

# print("\n" + str(sub_13_coord[0]))
# print(sub_13[0])

# transform from Milky Way rest frame to heliocentric rest frame by adding sun velocity vector to star velocity vector
for i in range(len(sub_13)):
    # add sun_vel
    sub_13_vel[i] = [sub_13_vel[i][0] - (sun_vel[0] / trafo), sub_13_vel[i][1] - (
        sun_vel[1] / trafo), sub_13_vel[i][2] - (sun_vel[2] / trafo)]

    # and recalculate the velocity magnitudes accordingly
    sub_13_mag_vel[i] = ((sub_13_vel[i][0]) ** 2 +
                         (sub_13_vel[i][1]) ** 2 + (sub_13_vel[i][2]) ** 2) ** 0.5


# repeat for sub50 velocites
# and write the adjusted velocities into the sub50 result file
for i in range(len(sub_50)):
    # add sun_vel
    sub_50_vel[i] = [sub_50_vel[i][0] - (sun_vel[0] / trafo), sub_50_vel[i][1] - (
        sun_vel[1] / trafo), sub_50_vel[i][2] - (sun_vel[2] / trafo)]

    # and recalculate the velocity magnitudes accordingly
    sub_50_mag_vel[i] = ((sub_50_vel[i][0]) ** 2 +
                         (sub_50_vel[i][1]) ** 2 + (sub_50_vel[i][2]) ** 2) ** 0.5

    # write results into secondary results file for sub_50 data
    h.write(str(sub_50[i]) + " " + str(sub_50_t[i]) + " " + str(sub_50_mag_vel[i]) + " " + str(sub_50_vel[i][0]) + " " + str(
        sub_50_vel[i][1]) + " " + str(sub_50_vel[i][2]) + " " + str(sub_50_ini_vel[i]) + " " + str(sub_50_ini_time[i]) + " " + "\n")


#
'''TRANSFORMATION TO GALACTIC COORDINATES:'''
#

# define galactic coordinate array with [gal. longitude, gal.latitude] and ICRS array with [RA, Dec]
gal_coord = []
RA_dec_coord = []
gal_l = []
gal_b = []
vel_l = []
vel_b = []


# transform Galactic Cartesian system to spherical coordinates without radius = Galactic coordinates
for i in range(len(sub_13)):
    gal_coord.append([np.arctan2(sub_13_coord[i][1], sub_13_coord[i][0]), np.arcsin(
        sub_13_coord[i][2] / sub_13[i])])
    gal_coord[i] = [gal_coord[i][0] *
                    (180 / np.pi), gal_coord[i][1] * (180 / np.pi)]

    # make separate arrays for l and b for easier plotting
    gal_l.append(np.arctan2(sub_13_coord[i][1], sub_13_coord[i][0]))
    gal_l[i] = gal_l[i] * (180 / np.pi)

    gal_b.append(np.arcsin(sub_13_coord[i][2] / sub_13[i]))
    gal_b[i] = gal_b[i] * (180 / np.pi)

    # same for velocity vectors
    vel_l.append(np.arctan2(sub_13_vel[i][1], sub_13_vel[i][0]))
    vel_l[i] = vel_l[i] * (180 / np.pi)

    vel_b.append(np.arcsin(sub_13_vel[i][2] / sub_13_mag_vel[i]))
    vel_b[i] = vel_b[i] * (180 / np.pi)

    # print(gal_coord[i])


# print(gal_coord)

# write galactic coordinates into new list with Skycoord for plotting
gal = SkyCoord(gal_l[:], gal_b[:], frame="galactic", unit="deg")
gal_v = SkyCoord(vel_l[:], vel_b[:], frame="galactic", unit="deg")


# finally, transform galactic coordinates to right ascension & declination using astropy and Skycoord
for i in range(len(sub_13)):
    RA_dec_coord.append(SkyCoord(
        l=gal_coord[i][0], b=gal_coord[i][1], unit="deg", frame="galactic"))
    # print(RA_dec_coord[i])

    # transform to ICRS equatorial coordinates with Skycoord builtin function
    RA_dec_coord[i] = RA_dec_coord[i].icrs

    # print(RA_dec_coord[i])
    # print(RA_dec_coord[i].to_string('hmsdms'))


#
'''WRITE FINAL RESULTS INTO FILE:'''
#

# print the number of min distances below 50kpc compared to below 15kpc
print("\n" + "number of min distances under 50kpc to Sun compared to under 15kpc to Sun" +
      "\n" + str(len(sub_50)))
print(len(sub_13))

# print(sub_200)

# write transformed HVS vectors and distance to the Sun in main results file
for i in range(len(sub_13)):
    g.write(str(sub_13[i]) + " " + str(sub_13_t[i]) + " " + str(gal_coord[i][0]) + " " + str(gal_coord[i][1]) + " " + str(RA_dec_coord[i].to_string('hmsdms')) + " " +
            str(sub_13_mag_vel[i]) + " " + str(sub_13_vel[i][0]) + " " + str(sub_13_vel[i][1]) + " " + str(sub_13_vel[i][2]) + " " + str(vel_l[i]) + " " + str(vel_b[i]) + " " + str(sub_13_ini_time[i]) + "\n")
